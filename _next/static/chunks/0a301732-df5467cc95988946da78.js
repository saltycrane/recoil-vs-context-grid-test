"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[970],{2804:function(e,t,n){n.d(t,{Wh:function(){return La},xu:function(){return Ma},FV:function(){return Ca},Zl:function(){return Ba}});var o=n(7294),r=n(3935);var a=function(e){return!!e&&"function"===typeof e.then};var i=function(e,t){if(null!=e)return e;throw new Error(null!==t&&void 0!==t?t:"Got unexpected null or undefined")};class s{}const u=new s,c={valueMaybe(){},valueOrThrow(){throw new Error(`Loadable expected value, but in "${this.state}" state`)},errorMaybe(){},errorOrThrow(){throw new Error(`Loadable expected error, but in "${this.state}" state`)},promiseMaybe(){},promiseOrThrow(){throw new Error(`Loadable expected promise, but in "${this.state}" state`)},is(e){return e.state===this.state&&e.contents===this.contents},map(e){if("hasError"===this.state)return this;if("hasValue"===this.state)try{const t=e(this.contents);return a(t)?f(t.then((e=>({__value:e})))):l(t)}catch(t){return a(t)?f(t.next((()=>e(this.contents)))):d(t)}if("loading"===this.state)return f(this.contents.then((t=>({__value:e(t.__value)}))).catch((t=>{if(a(t))return t.then((()=>e(this.contents)));throw t})));throw new Error("Invalid Loadable state")}};function l(e){return Object.freeze({state:"hasValue",contents:e,...c,getValue(){return this.contents},toPromise(){return Promise.resolve(this.contents)},valueMaybe(){return this.contents},valueOrThrow(){return this.contents}})}function d(e){return Object.freeze({state:"hasError",contents:e,...c,getValue(){throw this.contents},toPromise(){return Promise.reject(this.contents)},errorMaybe(){return this.contents},errorOrThrow(){return this.contents}})}function f(e){return Object.freeze({state:"loading",contents:e,...c,getValue(){throw this.contents.then((({__value:e})=>e))},toPromise(){return this.contents.then((({__value:e})=>e))},promiseMaybe(){return this.contents.then((({__value:e})=>e))},promiseOrThrow(){return this.contents.then((({__value:e})=>e))}})}var h,p={loadableWithValue:l,loadableWithError:d,loadableWithPromise:f,loadableLoading:function(){return f(new Promise((()=>{})))},loadableAll:function(e){return e.every((e=>"hasValue"===e.state))?l(e.map((e=>e.contents))):e.some((e=>"hasError"===e.state))?d(i(e.find((e=>"hasError"===e.state)),"Invalid loadable passed to loadableAll").contents):f(Promise.all(e.map((e=>e.contents))).then((e=>({__value:e}))))},Canceled:s,CANCELED:u};const v=null!==(h=o.useMutableSource)&&void 0!==h?h:o.unstable_useMutableSource;var y={mutableSourceExists:function(){return v&&!("undefined"!==typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:v};const{mutableSourceExists:_}=y,m=(new Map).set("recoil_hamt_2020",!0).set("recoil_memory_managament_2020",!0).set("recoil_suppress_rerender_in_callback",!0);function g(e){var t;return!("recoil_early_rendering_2021"===e&&!_())&&(null!==(t=m.get(e))&&void 0!==t&&t)}g.setPass=e=>{m.set(e,!0)},g.setFail=e=>{m.set(e,!1)};var S=g;var w=function(e,t,{error:n}={}){return null};var b={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach((e=>n.delete(e))),n}};var T=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};var R=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};var A=function(e,...t){0};function E(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class N{constructor(e){E(this,"key",void 0),this.key=e}}class k extends N{}class V extends N{}var L={AbstractRecoilValue:N,RecoilState:k,RecoilValueReadOnly:V,isRecoilValue:function(e){return e instanceof k||e instanceof V}},M=L.AbstractRecoilValue,C=L.RecoilState,B=L.RecoilValueReadOnly,U=L.isRecoilValue,D=Object.freeze({__proto__:null,AbstractRecoilValue:M,RecoilState:C,RecoilValueReadOnly:B,isRecoilValue:U});class x{}const I=new x;class z extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const F=new Map,O=new Map;class P extends Error{}const $=new Map;function q(e){return $.get(e)}var W={nodes:F,recoilValues:O,registerNode:function(e){if(F.has(e.key)){const t=`Duplicate atom key "${e.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(t)}F.set(e.key,e);const t=null==e.set?new D.RecoilValueReadOnly(e.key):new D.RecoilState(e.key);return O.set(e.key,t),t},getNode:function(e){const t=F.get(e);if(null==t)throw new P(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return F.get(e)},deleteNodeConfigIfPossible:function(e){var t;if(!S("recoil_memory_managament_2020"))return;const n=F.get(e);var o;(null===n||void 0===n||null===(t=n.shouldDeleteConfigOnRelease)||void 0===t?void 0:t.call(n))&&(F.delete(e),null===(o=q(e))||void 0===o||o(),$.delete(e))},setConfigDeletionHandler:function(e,t){S("recoil_memory_managament_2020")&&(void 0===t?$.delete(e):$.set(e,t))},getConfigDeletionHandler:q,recoilValuesForKeys:function(e){return R(e,(e=>i(O.get(e))))},NodeMissingError:P,DefaultValue:x,DEFAULT_VALUE:I,RecoilValueNotReady:z};class G{}var j={RetentionZone:G,retentionZone:function(){return new G}};const{setByAddingToSet:H}=b,{getNode:K,getNodeMaybe:Z,recoilValuesForKeys:J}=W,{RetentionZone:Q}=j,X=Object.freeze(new Set);class Y extends Error{}function ee(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=K(n),i=function(e,t,n){if(!S("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof Q)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!S("recoil_memory_managament_2020"))return;const o=e.getState().retention.nodesRetainedByZone;function r(e){const n=o.get(e);n&&n.delete(t),n&&0===n.size&&o.delete(e)}if(n instanceof Q)r(n);else if(Array.isArray(n))for(const e of n)r(e)}}(e,n,a.retainedBy),s=a.init(e,t,o);r.nodeCleanupFunctions.set(n,(()=>{s(),i()}))}function te(e,t,n){return K(n).peek(e,t)}function ne(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let s=r.pop();s;s=r.pop()){var i;o.add(s);const e=null!==(i=a.nodeToNodeSubscriptions.get(s))&&void 0!==i?i:X;for(const t of e)o.has(t)||r.push(t)}return o}var oe={getNodeLoadable:function(e,t,n){return ee(e,t,n,"get"),K(n).get(e,t)},peekNodeLoadable:te,setNodeValue:function(e,t,n,o){const r=K(n);if(null==r.set)throw new Y(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return ee(e,t,n,"set"),a(e,t,o)},cleanUpNode:function(e,t){var n;const o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=Z(t);return null===r||void 0===r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:H(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){var o,r,a;const i=e.getState(),s=e.getGraph(t.version),u=i.knownAtoms.has(n)?"atom":i.knownSelectors.has(n)?"selector":void 0,c=T(ne(e,t,new Set([n])),(e=>e!==n));return{loadable:te(e,t,n),isActive:i.knownAtoms.has(n)||i.knownSelectors.has(n),isSet:"selector"!==u&&t.atomValues.has(n),isModified:t.dirtyAtoms.has(n),type:u,deps:J(null!==(o=s.nodeDeps.get(n))&&void 0!==o?o:[]),subscribers:{nodes:J(c),components:R(null!==(r=null===(a=i.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],(([e])=>({name:e})))}}},getDownstreamNodes:ne,initializeNodeIfNewToStore:ee};const{CANCELED:re}=p,{getDownstreamNodes:ae,getNodeLoadable:ie,setNodeValue:se}=oe,{getNodeMaybe:ue}=W,{DefaultValue:ce,RecoilValueNotReady:le}=W,{AbstractRecoilValue:de,RecoilState:fe,RecoilValueReadOnly:he,isRecoilValue:pe}=D;function ve(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"===typeof o){const r=ie(e,t,n);if("loading"===r.state)throw new le(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),i=se(e,t,o.key,a);for(const[e,n]of i.entries())ye(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;ye(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=ue(e);null===a||void 0===a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else w(`Unknown action ${n.type}`)}function ye(e,t,n){"hasValue"===n.state&&n.contents instanceof ce?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function _e(e,t){e.replaceState((n=>{const o=Se(n);for(const r of t)ve(e,o,r);return we(e,o),o}))}function me(e,t){if(ge.length){const n=ge[ge.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else _e(e,[t])}const ge=[];function Se(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function we(e,t){const n=ae(e,t,t.dirtyAtoms);for(const a of n){var o,r;null===(o=ue(a))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function be(e,t,n){me(e,{type:"set",recoilValue:t,valueOrUpdater:n})}let Te=0;var Re={RecoilValueReadOnly:he,AbstractRecoilValue:de,RecoilState:fe,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&w("Tried to read from a discarded tree");const i=ie(e,n,t);return"loading"===i.state&&i.contents.catch((()=>re)),i},setRecoilValue:be,setRecoilValueLoadable:function(e,t,n){if(n instanceof ce)return be(e,t,n);me(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){me(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){me(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=Te++,a=e.getState();if(a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),i(a.nodeToComponentSubscriptions.get(t)).set(r,[null!==o&&void 0!==o?o:"<not captured>",n]),S("recoil_early_rendering_2021")){const o=e.getState().nextTree;o&&o.dirtyAtoms.has(t)&&n(o)}return{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):w(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:pe,applyAtomValueWrites:function(e,t){const n=e.clone();return t.forEach(((e,t)=>{"hasValue"===e.state&&e.contents instanceof ce?n.delete(t):n.set(t,e)})),n},batchStart:function(){const e=new Map;return ge.push(e),()=>{for(const[t,n]of e)_e(t,n);ge.pop()!==e&&w("Incorrect order of batch popping")}},writeLoadableToTreeState:ye,invalidateDownstreams:we,copyTreeState:Se,invalidateDownstreams_FOR_TESTING:we};const{unstable_batchedUpdates:Ae}=r;var Ee={unstable_batchedUpdates:Ae};const{unstable_batchedUpdates:Ne}=Ee;var ke={unstable_batchedUpdates:Ne};const{batchStart:Ve}=Re,{unstable_batchedUpdates:Le}=ke;let Me=Le;var Ce={getBatcher:()=>Me,setBatcher:e=>{Me=e},batchUpdates:e=>{Me((()=>{let t=()=>{};try{t=Ve(),e()}finally{t()}}))}};var Be={enqueueExecution:function(e,t){t()}};var Ue=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};var De=function(e,t){const n=new Map;return e.forEach(((e,o)=>{n.set(o,t(e,o))})),n};function xe(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach(((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:Ue(e,a)).forEach((e=>{r.has(e)||r.set(e,new Set);i(r.get(e)).add(t)})),a){Ue(a,e).forEach((e=>{if(!r.has(e))return;const n=i(r.get(e));n.delete(t),0===n.size&&r.delete(e)}))}}))}var Ie={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),i(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:De(e.nodeDeps,(e=>new Set(e))),nodeToNodeSubscriptions:De(e.nodeToNodeSubscriptions,(e=>new Set(e)))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach(((e,n)=>{t.has(n)||t.set(n,new Set);const o=i(t.get(n));e.forEach((e=>o.add(e)))}))},saveDependencyMapToStore:function(e,t,n){var o,r,a,i;const s=t.getState();n!==s.currentTree.version&&n!==(null===(o=s.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=s.previousTree)||void 0===r?void 0:r.version)&&w("Tried to save dependencies to a discarded tree");const u=t.getGraph(n);if(xe(e,u),n===(null===(a=s.previousTree)||void 0===a?void 0:a.version)){xe(e,t.getGraph(s.currentTree.version),u)}if(n===(null===(i=s.previousTree)||void 0===i?void 0:i.version)||n===s.currentTree.version){var c;const n=null===(c=s.nextTree)||void 0===c?void 0:c.version;if(void 0!==n){xe(e,t.getGraph(n),u)}}}};var ze,Fe=(function(e){var t="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o=Math.pow(2,5),r=o-1,a=o/2,i=o/4,s={},u=function(e){return function(){return e}},c=n.hash=function(e){var n="undefined"===typeof e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r)o=(o<<5)-o+e.charCodeAt(r)|0;return o},l=function(e,t){return t>>>e&r},d=function(e){return 1<<e},f=function(e,t){return n=e&t-1,n=(n=(858993459&(n-=n>>1&1431655765))+(n>>2&858993459))+(n>>4)&252645135,127&(n+=n>>8)+(n>>16);var n},h=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=new Array(a);for(var i=0;i<a;++i)r[i]=o[i]}return r[t]=n,r},p=function(e,t,n){var o=n.length-1,r=0,a=0,i=n;if(e)r=a=t;else for(i=new Array(o);r<t;)i[a++]=n[r++];for(++r;r<=o;)i[a++]=n[r++];return e&&(i.length=o),i},v={__hamt_isEmpty:!0},y=function(e){return e===v||e&&e.__hamt_isEmpty},_=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:T}},m=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:R}},g=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},S=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},w=function e(t,n,o,r,a,i){if(o===a)return m(t,o,[i,r]);var s=l(n,o),u=l(n,a);return g(t,d(s)|d(u),s===u?[e(t,n+5,o,r,a,i)]:s<u?[r,i]:[i,r])},b=function(e,t){return e===t.edit},T=function(e,t,n,o,r,a,i){if(t(a,this.key)){var u=o(this.value);return u===this.value?this:u===s?(--i.value,v):b(e,this)?(this.value=u,this):_(e,r,a,u)}var c=o();return c===s?this:(++i.value,w(e,n,this.hash,this,r,_(e,r,a,c)))},R=function(e,t,n,o,r,a,i){if(r===this.hash){var u=function(e,t,n,o,r,a,i,u){for(var c=r.length,l=0;l<c;++l){var d=r[l];if(n(i,d.key)){var f=d.value,v=a(f);return v===f?r:v===s?(--u.value,p(e,l,r)):h(e,l,_(t,o,i,v),r)}}var y=a();return y===s?r:(++u.value,h(e,c,_(t,o,i,y),r))}(b(e,this),e,t,this.hash,this.children,o,a,i);return u===this.children?this:u.length>1?m(e,this.hash,u):u[0]}var c=o();return c===s?this:(++i.value,w(e,n,this.hash,this,r,_(e,r,a,c)))},A=function(e,t,n,o,r,i,s){var u=this.mask,c=this.children,_=l(n,r),m=d(_),w=f(u,m),T=u&m,R=T?c[w]:v,A=R._modify(e,t,n+5,o,r,i,s);if(R===A)return this;var E,N=b(e,this),k=u,V=void 0;if(T&&y(A)){if(!(k&=~m))return v;if(c.length<=2&&((E=c[1^w])===v||1===E.type||2===E.type))return c[1^w];V=p(N,w,c)}else if(T||y(A))V=h(N,w,A,c);else{if(c.length>=a)return function(e,t,n,o,r){for(var a=[],i=o,s=0,u=0;i;++u)1&i&&(a[u]=r[s++]),i>>>=1;return a[t]=n,S(e,s+1,a)}(e,_,A,u,c);k|=m,V=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var i=0,s=0,u=new Array(r+1);i<t;)u[s++]=o[i++];for(u[t]=n;i<r;)u[++s]=o[i++];return u}(N,w,A,c)}return N?(this.mask=k,this.children=V,this):g(e,k,V)},E=function(e,t,n,o,r,a,s){var u=this.size,c=this.children,d=l(n,r),f=c[d],p=(f||v)._modify(e,t,n+5,o,r,a,s);if(f===p)return this;var _=b(e,this),m=void 0;if(y(f)&&!y(p))++u,m=h(_,d,p,c);else if(!y(f)&&y(p)){if(--u<=i)return function(e,t,n,o){for(var r=new Array(t-1),a=0,i=0,s=0,u=o.length;s<u;++s)if(s!==n){var c=o[s];c&&!y(c)&&(r[a++]=c,i|=1<<s)}return g(e,i,r)}(e,u,d,c);m=h(_,d,v,c)}else m=h(_,d,p,c);return _?(this.size=u,this.children=m,this):S(e,u,m)};function N(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}v._modify=function(e,t,n,o,r,a,i){var u=o();return u===s?v:(++i.value,_(e,r,a,u))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,i=o._config.keyEq;;)switch(r.type){case 1:return i(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var s=r.children,u=0,c=s.length;u<c;++u){var h=s[u];if(i(n,h.key))return h.value}return e;case 3:var p=l(a,t),v=d(p);if(r.mask&v){r=r.children[f(r.mask,v)],a+=5;break}return e;case 4:if(r=r.children[l(a,t)]){a+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var V=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return V(e,t,this)};var L=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return L(e,t,this)},n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)},N.prototype.get=function(e,t){return V(t,e,this)};var M=n.has=function(e,t,n){return k(s,e,t,n)!==s};N.prototype.hasHash=function(e,t){return M(e,t,this)};var C=n.has=function(e,t){return M(t._config.hash(e),e,t)};N.prototype.has=function(e){return C(e,this)};var B=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||B,hash:e&&e.hash||c},v,0)},n.empty=n.make();var U=n.isEmpty=function(e){return e&&!!y(e._root)};N.prototype.isEmpty=function(){return U(this)};var D=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};N.prototype.modifyHash=function(e,t,n){return D(n,e,t,this)};var x=n.modify=function(e,t,n){return D(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return x(t,e,this)};var I=n.setHash=function(e,t,n,o){return D(u(n),e,t,o)};N.prototype.setHash=function(e,t,n){return I(e,t,n,this)};var z=n.set=function(e,t,n){return I(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return z(e,t,this)};var F=u(s),O=n.removeHash=function(e,t,n){return D(F,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return O(e,t,this)};var P=n.remove=function(e,t){return O(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return P(e,this)};var $=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return $(this)};var q=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return q(this)};var W=n.mutate=function(e,t){var n=$(t);return e(n),q(n)};N.prototype.mutate=function(e){return W(e,this)};var G=function(e){return e&&j(e[0],e[1],e[2],e[3],e[4])},j=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!y(a))return H(a,o,[e,t,n,o,r])}return G(r)},H=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return j(o.length,o,0,t,n);default:return G(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=G(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var J=function(e,t){return new Z(H(e._root,t))},Q=function(e){return[e.key,e.value]},X=n.entries=function(e){return J(e,Q)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return X(this)};var Y=function(e){return e.key},ee=n.keys=function(e){return J(e,Y)};N.prototype.keys=function(){return ee(this)};var te=function(e){return e.value},ne=n.values=N.prototype.values=function(e){return J(e,te)};N.prototype.values=function(){return ne(this)};var oe=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var i=0,s=a.length;i<s;){var u=a[i++];u&&u.type&&(1===u.type?t=e(t,u.value,u.key):r.push(u.children))}return t};N.prototype.fold=function(e,t){return oe(e,t,this)};var re=n.forEach=function(e,t){return oe((function(n,o,r){return e(o,r,t)}),null,t)};N.prototype.forEach=function(e){return re(e,this)};var ae=n.count=function(e){return e._size};N.prototype.count=function(){return ae(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n}(ze={exports:{}},ze.exports),ze.exports);class Oe{constructor(e){E(this,"_map",void 0),this._map=new Map(null===e||void 0===e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return $e(this)}toMap(){return new Map(this._map)}}class Pe{constructor(e){if(E(this,"_hamt",Fe.empty.beginMutation()),e instanceof Pe){const t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(const[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return $e(this)}toMap(){return new Map(this._hamt)}}function $e(e){return S("recoil_hamt_2020")?new Pe(e):new Oe(e)}var qe=$e,We=Object.freeze({__proto__:null,persistentMap:qe});const{graph:Ge}=Ie,{persistentMap:je}=We;let He=0;const Ke=()=>He++;function Ze(){const e=Ke();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:je(),nonvalidatedAtoms:je()}}var Je={makeEmptyTreeState:Ze,makeEmptyStoreState:function(){const e=Ze();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,Ge()),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:Ke};var Qe=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};var Xe=function(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};const{cleanUpNode:Ye}=oe,{deleteNodeConfigIfPossible:et,getNode:tt}=W,{RetentionZone:nt}=j,ot=new Set;function rt(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return void w("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const r=new Set;for(const i of t)if(i instanceof nt)for(const e of it(n,i))r.add(e);else r.add(i);const a=function(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return u(t),a;function u(t){const c=new Set,l=function(e,t,n,o,r){const a=e.getGraph(t.version),s=[],u=new Set;for(;n.size>0;)c(i(n.values().next().value));return s;function c(e){if(o.has(e)||r.has(e))return void n.delete(e);if(u.has(e))return;const t=a.nodeToNodeSubscriptions.get(e);if(t)for(const n of t)c(n);u.add(e),n.delete(e),s.push(e)}}(e,o,t,a,s);for(const e of l){var d;if("recoilRoot"===tt(e).retainedBy){s.add(e);continue}if((null!==(d=n.retention.referenceCounts.get(e))&&void 0!==d?d:0)>0){s.add(e);continue}if(st(e).some((e=>n.retention.referenceCounts.get(e)))){s.add(e);continue}const t=r.nodeToNodeSubscriptions.get(e);t&&Xe(t,(e=>s.has(e)))?s.add(e):(a.add(e),c.add(e))}const f=new Set;for(const e of c)for(const t of null!==(h=r.nodeDeps.get(e))&&void 0!==h?h:ot){var h;a.has(t)||f.add(t)}f.size&&u(f)}}(e,r);for(const i of a)at(e,o,i)}function at(e,t,n){if(!S("recoil_memory_managament_2020"))return;Ye(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=st(n);for(const u of r){var a;null===(a=o.retention.nodesRetainedByZone.get(u))||void 0===a||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const i=o.graphsByVersion.get(t.version);if(i){const e=i.nodeDeps.get(n);if(void 0!==e){i.nodeDeps.delete(n);for(const t of e){var s;null===(s=i.nodeToNodeSubscriptions.get(t))||void 0===s||s.delete(n)}}i.nodeToNodeSubscriptions.delete(n)}et(n)}function it(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:ot}function st(e){const t=tt(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof nt?[t]:t}function ut(e,t){if(!S("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),function(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):rt(e,new Set([t]))}(e,t)}var ct={updateRetainCount:function(e,t,n){var o;if(!S("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?ut(e,t):r.set(t,a)},updateRetainCountToZero:ut,releaseScheduledRetainablesNow:function(e){if(!S("recoil_memory_managament_2020"))return;const t=e.getState();rt(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};var lt=function*(e){for(const t of e)for(const e of t)yield e};var dt={isSSR:"undefined"===typeof window,isReactNative:"undefined"!==typeof navigator&&"ReactNative"===navigator.product};const{isSSR:ft}=dt,{batchUpdates:ht}=Ce,{initializeNodeIfNewToStore:pt,peekNodeInfo:vt}=oe,{graph:yt}=Ie,{DEFAULT_VALUE:_t,recoilValues:mt,recoilValuesForKeys:gt}=W,{AbstractRecoilValue:St,getRecoilValueAsLoadable:wt,setRecoilValue:bt,setUnvalidatedRecoilValue:Tt}=Re,{updateRetainCount:Rt}=ct,{getNextTreeStateVersion:At,makeEmptyStoreState:Et}=Je;class Nt{constructor(e){E(this,"_store",void 0),E(this,"_refCount",0),E(this,"getLoadable",(e=>(this.checkRefCount_INTERNAL(),wt(this._store,e)))),E(this,"getPromise",(e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise()))),E(this,"getNodes_UNSTABLE",(e=>{if(this.checkRefCount_INTERNAL(),!0===(null===e||void 0===e?void 0:e.isModified)){if(!1===(null===e||void 0===e?void 0:e.isInitialized))return[];const t=this._store.getState().currentTree;return gt(t.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null===e||void 0===e?void 0:e.isInitialized)?mt.values():!0===e.isInitialized?gt(lt([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):T(mt.values(),(({key:e})=>!t.has(e)&&!n.has(e)))})),E(this,"getInfo_UNSTABLE",(({key:e})=>(this.checkRefCount_INTERNAL(),vt(this._store,this._store.getState().currentTree,e)))),E(this,"map",(e=>{this.checkRefCount_INTERNAL();const t=new Lt(this,ht);return e(t),Vt(t.getStore_INTERNAL())})),E(this,"asyncMap",(async e=>{this.checkRefCount_INTERNAL();const t=new Lt(this,ht);return await e(t),Vt(t.getStore_INTERNAL())})),this._store={getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return i(n.get(t));const o=yt();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}};for(const t of this._store.getState().nodeCleanupFunctions.keys())pt(this._store,e.currentTree,t,"get"),Rt(this._store,t,1);this.retain(),this.autorelease_INTERNAL()}retain(){if(!S("recoil_memory_managament_2020"))return()=>{};this._refCount++;let e=!1;return()=>{e||(e=!0,this.release_INTERNAL())}}autorelease_INTERNAL(){S("recoil_memory_managament_2020")&&(ft||window.setTimeout((()=>this.release_INTERNAL()),0))}release_INTERNAL(){S("recoil_memory_managament_2020")&&(this._refCount--,this._refCount)}checkRefCount_INTERNAL(){S("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this.getID_INTERNAL()}getID_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function kt(e,t,n=!1){const o=e.getState(),r=n?At():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}function Vt(e,t="current"){const n=e.getState(),o="current"===t?n.currentTree:i(n.previousTree);return new Nt(kt(e,o))}class Lt extends Nt{constructor(e,t){super(kt(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),E(this,"_batch",void 0),E(this,"set",((e,t)=>{this.checkRefCount_INTERNAL();const n=this.getStore_INTERNAL();this._batch((()=>{Rt(n,e.key,1),bt(this.getStore_INTERNAL(),e,t)}))})),E(this,"reset",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();this._batch((()=>{Rt(t,e.key,1),bt(this.getStore_INTERNAL(),e,_t)}))})),E(this,"setUnvalidatedAtomValues_DEPRECATED",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();ht((()=>{for(const[n,o]of e.entries())Rt(t,n,1),Tt(t,new St(n),o)}))})),this._batch=t}}var Mt={Snapshot:Nt,MutableSnapshot:Lt,freshSnapshot:function(e){const t=new Nt(Et());return null!=e?t.map(e):t},cloneSnapshot:Vt},Ct=Mt.Snapshot,Bt=Mt.MutableSnapshot,Ut=Mt.freshSnapshot,Dt=Mt.cloneSnapshot,xt=Object.freeze({__proto__:null,Snapshot:Ct,MutableSnapshot:Bt,freshSnapshot:Ut,cloneSnapshot:Dt});const{getNextTreeStateVersion:It,makeEmptyStoreState:zt}=Je,{cleanUpNode:Ft,getDownstreamNodes:Ot,setNodeValue:Pt,setUnvalidatedAtomValue_DEPRECATED:$t}=oe,{graph:qt}=Ie,{cloneGraph:Wt}=Ie,{applyAtomValueWrites:Gt}=Re,{releaseScheduledRetainablesNow:jt}=ct,{freshSnapshot:Ht}=xt,{useCallback:Kt,useContext:Zt,useEffect:Jt,useMemo:Qt,useRef:Xt,useState:Yt}=o;function en(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const tn=Object.freeze({getState:en,replaceState:en,getGraph:en,subscribeToTransactions:en,addTransactionMetadata:en});let nn=!1;function on(e){if(nn)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(null===t.nextTree){S("recoil_memory_managament_2020")&&S("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&jt(e);const n=t.currentTree.version,o=It();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Wt(i(t.graphsByVersion.get(n))))}}const rn=o.createContext({current:tn}),an=()=>Zt(rn),sn=o.createContext(null);function un(e,t,n){const o=Ot(e,n,n.dirtyAtoms);for(const r of o){const e=t.nodeToComponentSubscriptions.get(r);if(e)for(const[t,[o,r]]of e)r(n)}}function cn(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,r]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,o]of r)o(e);for(const[n,o]of t.transactionSubscriptions)o(e);S("recoil_early_rendering_2021")&&!t.suspendedComponentResolvers.size||(un(e,t,n),t.suspendedComponentResolvers.forEach((e=>e())),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach((e=>e(n))),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function ln({setNotifyBatcherOfChange:e}){const t=an(),[n,o]=Yt([]);return e((()=>o({}))),Jt((()=>{Be.enqueueExecution("Batcher",(()=>{!function(e){const t=e.current.getState();t.commitDepth++;try{const{nextTree:n}=t;if(null===n)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,cn(e.current),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):w("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,S("recoil_memory_managament_2020")&&jt(e.current)}finally{t.commitDepth--}}(t)}))})),Jt((()=>()=>{e((()=>{}))}),[e]),null}let dn=0;function fn({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:r}){var a;let s;const u=Xt(null),c=Kt((e=>{u.current=e}),[u]),l=null!==(a=o.createMutableSource)&&void 0!==a?a:o.unstable_createMutableSource,d=null!==n&&void 0!==n?n:{getState:()=>s.current,replaceState:e=>{const t=f.current.getState();on(f.current);const n=i(t.nextTree);let o;try{nn=!0,o=e(n)}finally{nn=!1}o!==n&&(t.nextTree=o,S("recoil_early_rendering_2021")&&un(d,t,o),i(u.current)())},getGraph:e=>{const t=s.current.graphsByVersion;if(t.has(e))return i(t.get(e));const n=qt();return t.set(e,n),n},subscribeToTransactions:(e,t)=>{if(null==t){const{transactionSubscriptions:t}=f.current.getState(),n=dn++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=f.current.getState();n.has(t)||n.set(t,new Map);const o=dn++;return i(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},addTransactionMetadata:e=>{on(f.current);for(const t of Object.keys(e))i(f.current.getState().nextTree).transactionMetadata[t]=e[t]}},f=Xt(d);s=Xt(null!=e?function(e,t){const n=zt();return t({set:(t,o)=>{const r=n.currentTree,a=Pt(e,r,t.key,o),i=new Set(a.keys()),s=r.nonvalidatedAtoms.clone();for(const e of i)s.delete(e);n.currentTree={...r,dirtyAtoms:Qe(r.dirtyAtoms,i),atomValues:Gt(r.atomValues,a),nonvalidatedAtoms:s}},setUnvalidatedAtomValues:e=>{e.forEach(((e,t)=>{n.currentTree=$t(n.currentTree,t,e)}))}}),n}(d,e):null!=t?function(e){return Ht().map(e).getStore_INTERNAL().getState()}(t):zt());const h=Qt((()=>l?l(s,(()=>s.current.currentTree.version)):null),[l,s]);return Jt((()=>()=>{for(const e of f.current.getState().knownAtoms)Ft(f.current,e)}),[]),o.createElement(rn.Provider,{value:f},o.createElement(sn.Provider,{value:h},o.createElement(ln,{setNotifyBatcherOfChange:c}),r))}var hn={useStoreRef:an,useRecoilMutableSource:function(){const e=Zt(sn);return null==e&&A("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},RecoilRoot:function(e){const{override:t,...n}=e,r=an();return!1===t&&r.current!==tn?e.children:o.createElement(fn,n)},notifyComponents_FOR_TESTING:un,sendEndOfBatchNotifications_FOR_TESTING:cn};const{loadableWithValue:pn}=p,{DEFAULT_VALUE:vn,getNode:yn}=W,{copyTreeState:_n,getRecoilValueAsLoadable:mn,invalidateDownstreams:gn,writeLoadableToTreeState:Sn}=Re;function wn(e){return"atom"===yn(e.key).nodeType}class bn{constructor(e,t){E(this,"_store",void 0),E(this,"_treeState",void 0),E(this,"_changes",void 0),E(this,"get",(e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!wn(e))throw new Error("Reading selectors within atomicUpdate is not supported");const t=mn(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;throw"hasError"===t.state?t.contents:new Error(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)})),E(this,"set",((e,t)=>{if(!wn(e))throw new Error("Setting selectors within atomicUpdate is not supported");if("function"===typeof t){const n=this.get(e);this._changes.set(e.key,t(n))}else this._changes.set(e.key,t)})),E(this,"reset",(e=>{this.set(e,vn)})),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;const e=_n(this._treeState);for(const[t,n]of this._changes)Sn(e,t,pn(n));return gn(this._store,e),e}}var Tn=function(e){return t=>{e.replaceState((n=>{const o=new bn(e,n);return t(o),o.newTreeState_INTERNAL()}))}},Rn=Object.freeze({__proto__:null,atomicUpdater:Tn});var An=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var En=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var Nn=function(e,t){if(!e)throw new Error(t)};var kn=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};var Vn=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};const{useRef:Ln}=o;var Mn=function(){return Ln(),"<component name not available>"};const{atomicUpdater:Cn}=Rn,{batchUpdates:Bn}=Ce,{DEFAULT_VALUE:Un,getNode:Dn,nodes:xn}=W,{useRecoilMutableSource:In,useStoreRef:zn}=hn,{isRecoilValue:Fn}=D,{AbstractRecoilValue:On,getRecoilValueAsLoadable:Pn,setRecoilValue:$n,setRecoilValueLoadable:qn,setUnvalidatedRecoilValue:Wn,subscribeToRecoilValue:Gn}=Re,{updateRetainCount:jn}=ct,{RetentionZone:Hn}=j,{Snapshot:Kn,cloneSnapshot:Zn}=xt,{setByAddingToSet:Jn}=b,{isSSR:Qn}=dt,{mutableSourceExists:Xn,useMutableSource:Yn}=y,{useCallback:eo,useEffect:to,useMemo:no,useRef:oo,useState:ro}=o,ao=12e4;function io(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise((e=>{n.current.getState().suspendedComponentResolvers.add(e)}))}if("hasError"===e.state)throw e.contents;throw new Error(`Invalid value of loadable atom "${t.key}"`)}function so(e){return S("recoil_memory_managament_2020")&&_o(e),Xn()?function(e){const t=zn(),n=eo((()=>{var n;const o=t.current,r=o.getState(),a=S("recoil_early_rendering_2021")&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return Pn(o,e,a)}),[t,e]),o=eo((()=>n()),[n]),r=Mn(),a=eo(((o,a)=>{const i=t.current;return Gn(i,e,(()=>{if(!S("recoil_suppress_rerender_in_callback"))return a();const e=n();u.current.is(e)||a(),u.current=e}),r).release}),[t,e,r,n]),i=In(),s=Yn(i,o,a),u=oo(s);return to((()=>{u.current=s})),s}(e):function(e){const t=zn(),[n,o]=ro([]),r=Mn();to((()=>{const n=t.current,a=n.getState(),s=Gn(n,e,(t=>{var r;if(!S("recoil_suppress_rerender_in_callback"))return o([]);const a=Pn(n,e,n.getState().currentTree);(null===(r=i.current)||void 0===r?void 0:r.is(a))||o(a),i.current=a}),r);if(a.nextTree)n.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{i.current=null,o([])}));else{var u;if(!S("recoil_suppress_rerender_in_callback"))return o([]);const t=Pn(n,e,n.getState().currentTree);(null===(u=i.current)||void 0===u?void 0:u.is(t))||o(t),i.current=t}return s.release}),[r,e,t]);const a=Pn(t.current,e),i=oo(a);return to((()=>{i.current=a})),a}(e)}function uo(e){const t=zn();return io(so(e),e,t)}function co(e){const t=zn();return eo((n=>{$n(t.current,e,n)}),[t,e])}function lo(e){const t=zn();to((()=>t.current.subscribeToTransactions(e).release),[e,t])}function fo(e){const t=e.atomValues.toMap(),n=De(An(t,((e,t)=>{const n=Dn(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state})),(e=>e.contents));return kn(e.nonvalidatedAtoms.toMap(),n)}function ho(e){const t=oo();return to((()=>{t.current=e})),t.current}function po(){const e=zn();return eo((t=>{var n;const o=e.current.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Bn((()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,s;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(s=a.atomValues.get(t))||void 0===s?void 0:s.contents)&&Dn(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach((t=>{qn(e.current,new On(t),a.atomValues.has(t)?i(a.atomValues.get(t)):Un)})),e.current.replaceState((e=>({...e,stateID:t.getID_INTERNAL()})))}))}),[e])}class vo{}const yo=new vo;function _o(e){if(S("recoil_memory_managament_2020"))return function(e){const t=(Array.isArray(e)?e:[e]).map((e=>e instanceof Hn?e:e.key)),n=zn();to((()=>{if(!S("recoil_memory_managament_2020"))return;const e=n.current;if(o.current&&!Qn)window.clearTimeout(o.current),o.current=null;else for(const n of t)jn(e,n,1);return()=>{for(const n of t)jn(e,n,-1)}}),[n,...t]);const o=oo(),r=ho(t);if(!Qn&&(void 0===r||!Vn(r,t))){const e=n.current;for(const n of t)jn(e,n,1);if(r)for(const t of r)jn(e,t,-1);o.current&&window.clearTimeout(o.current),o.current=window.setTimeout((()=>{o.current=null;for(const n of t)jn(e,n,-1)}),ao)}}(e)}var mo={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useGotoRecoilSnapshot:po,useRecoilCallback:function(e,t){const n=zn(),o=po();return eo(((...t)=>{function r(e,t){$n(n.current,e,t)}function a(e){$n(n.current,e,Un)}const i=Zn(n.current),s=Cn(n.current);let u=yo;return Bn((()=>{const n="useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!==typeof e)throw new Error(n);const c=e({set:r,reset:a,snapshot:i,gotoSnapshot:o,transact_UNSTABLE:s});if("function"!==typeof c)throw new Error(n);u=c(...t)})),u instanceof vo&&Nn(!1),u}),null!=t?[...t,n]:void 0)},useRecoilInterface:function(){const e=zn(),[t,n]=ro([]),o=oo(new Set);o.current=new Set;const r=oo(new Set),a=oo(new Map),i=eo((e=>{const t=a.current.get(e);t&&(t.release(),a.current.delete(e))}),[a]),s=Mn();return to((()=>{const t=e.current;function u(e,t){a.current.has(t)&&n([])}Ue(o.current,r.current).forEach((e=>{if(a.current.has(e))return void A(`Double subscription to RecoilValue "${e}"`);const n=Gn(t,new On(e),(t=>{u(0,e)}),s);a.current.set(e,n);t.getState().nextTree?t.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{u(t.getState(),e)})):u(t.getState(),e)})),Ue(r.current,o.current).forEach((e=>{i(e)})),r.current=o.current})),to((()=>{const e=a.current;return()=>e.forEach(((e,t)=>i(t)))}),[i]),no((()=>{function t(t){return n=>{$n(e.current,t,n)}}function n(t){var n;o.current.has(t.key)||(o.current=Jn(o.current,t.key));const r=e.current.getState();return Pn(e.current,t,S("recoil_early_rendering_2021")&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree)}function r(t){return io(n(t),t,e)}return{getRecoilValue:r,getRecoilValueLoadable:n,getRecoilState:function(e){return[r(e),t(e)]},getRecoilStateLoadable:function(e){return[n(e),t(e)]},getSetRecoilState:t,getResetRecoilState:function(t){return()=>$n(e.current,t,Un)}}}),[o,e])},useRecoilSnapshot:function(){const e=zn(),[t,n]=ro((()=>Zn(e.current))),o=ho(t),r=oo();return to((()=>(r.current&&!Qn&&window.clearTimeout(r.current),t.retain())),[t]),lo(eo((e=>n(Zn(e))),[])),o===t||Qn||(r.current&&(null===o||void 0===o||o.release_INTERNAL(),window.clearTimeout(r.current)),t.retain(),r.current=window.setTimeout((()=>{t.release_INTERNAL(),r.current=null}),ao)),t},useRecoilState:function(e){return[uo(e),co(e)]},useRecoilStateLoadable:function(e){return[so(e),co(e)]},useRecoilTransaction:function(e,t){const n=zn();return no((()=>(...t)=>{Cn(n.current)((n=>{e(n)(...t)}))}),null!=t?[...t,n]:void 0)},useRecoilTransactionObserver:function(e){lo(eo((t=>{const n=Zn(t,"current"),o=Zn(t,"previous");e({snapshot:n,previousSnapshot:o})}),[e]))},useRecoilValue:uo,useRecoilValueLoadable:so,useRetain:_o,useResetRecoilState:function(e){const t=zn();return eo((()=>{$n(t.current,e,Un)}),[t,e])},useSetRecoilState:co,useSetUnvalidatedAtomValues:function(){const e=zn();return(t,n={})=>{Bn((()=>{e.current.addTransactionMetadata(n),t.forEach(((t,n)=>Wn(e.current,new On(n),t)))}))}},useTransactionObservation_DEPRECATED:function(e){lo(eo((t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(w("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=fo(o),a=fo(n),i=De(xn,(e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}})),s=En(o.dirtyAtoms,(e=>r.has(e)||a.has(e)));e({atomValues:r,previousAtomValues:a,atomInfo:i,modifiedAtoms:s,transactionMetadata:{...o.transactionMetadata}})}),[e]))},useTransactionSubscription_DEPRECATED:lo};const{peekNodeInfo:go}=oe,{useStoreRef:So}=hn;var wo=function(){const e=So();return({key:t})=>go(e.current,e.current.getState().currentTree,t)};const{RecoilRoot:bo,useStoreRef:To}=hn,{useMemo:Ro}=o;var Ao=function(){const e=To().current;return Ro((()=>function({children:t}){return o.createElement(bo,{store_INTERNAL:e},t)}),[e])};const{isReactNative:Eo,isSSR:No}=dt;function ko(e,t,n){if("string"===typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(!0!==(null===t||void 0===t?void 0:t.allowFunctions))throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";var o;if("object"!==typeof e)return null!==(o=JSON.stringify(e))&&void 0!==o?o:"";if(a(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map(((e,n)=>ko(e,t,n.toString())))}]`;if("function"===typeof e.toJSON)return ko(e.toJSON(n),t,n);if(e instanceof Map){const o={};for(const[n,r]of e)o["string"===typeof n?n:ko(n,t)]=r;return ko(o,t,n)}return e instanceof Set?ko(Array.from(e).sort(((e,n)=>ko(e,t).localeCompare(ko(n,t)))),t,n):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"===typeof e[Symbol.iterator]?ko(Array.from(e),t,n):`{${Object.keys(e).filter((t=>void 0!==e[t])).sort().map((n=>`${ko(n,t)}:${ko(e[n],t,n)}`)).join(",")}}`}var Vo=function(e,t={allowFunctions:!1}){return ko(e,t)};const Lo=(e,t,n)=>{var o;if(null==e)return;if(null===n||void 0===n||null===(o=n.onNodeVisit)||void 0===o||o.call(n,e),"leaf"===e.type)return e;const r=t(e.nodeKey);return Lo(e.branches.get(r),t,n)},Mo=(e,t,n,o,r,a)=>{var i;let s;if(null==e)if(0===t.length)s={type:"leaf",value:o,parent:n,branchKey:r};else{const[e,...i]=t,[u,c]=e;s={type:"branch",nodeKey:u,parent:n,branches:new Map,branchKey:r},s.branches.set(c,Mo(null,i,s,o,c,a))}else if(s=e,t.length){const[n,...r]=t,[i,s]=n;("branch"!==e.type||e.nodeKey!==i)&&Nn(!1),e.branches.set(s,Mo(e.branches.get(s),r,e,o,s,a))}return null===a||void 0===a||null===(i=a.onNodeVisit)||void 0===i||i.call(a,s),s},Co=(e,t,n)=>n?(n.branches.delete(t.branchKey),Bo(e,n,n.parent)):e===t,Bo=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),Bo(e,n,n.parent)):e===t,Uo=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce(((e,t)=>e+Uo(t)),0);var Do=class{constructor(e){var t,n,o;E(this,"_numLeafs",void 0),E(this,"_root",void 0),E(this,"_onHit",void 0),E(this,"_onSet",void 0),E(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(t=null===e||void 0===e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null===e||void 0===e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null===e||void 0===e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){return Lo(this.root(),(t=>this._mapNodeValue(e(t))),{onNodeVisit:e=>{null===t||void 0===t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let o;const r=Mo(this.root(),e.map((([e,t])=>[e,this._mapNodeValue(t)])),null,t,null,{onNodeVisit:e=>{null===n||void 0===n||n.onNodeVisit(e),"leaf"===e.type&&(o=e)}});this.root()||(this._root=r),this._numLeafs++,this._onSet(i(o))}delete(e){if(!this.root())return!1;const t=i(this.root());return!!Co(t,e,e.parent)&&(e===t||"branch"===t.type&&!t.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=Uo(e),!0))}clear(){this._numLeafs=0,this._root=null}},xo=Object.freeze({__proto__:null,TreeCache:Do});var Io=class{constructor(e){var t;E(this,"_maxSize",void 0),E(this,"_size",void 0),E(this,"_head",void 0),E(this,"_tail",void 0),E(this,"_map",void 0),E(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){const t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){const n=this._keyMapper(e);this._map.get(n)&&this.delete(e);const o=this.head(),r={key:e,right:o,left:null,value:t};o?o.left=r:this._tail=r,this._map.set(n,r),this._head=r,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const e=this.tail();e&&this.delete(e.key)}delete(e){const t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;const n=i(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},zo=Object.freeze({__proto__:null,LRUCache:Io});const{LRUCache:Fo}=zo,{TreeCache:Oo}=xo;var Po=function(e,t=(e=>e)){const n=new Fo({maxSize:e}),o=new Oo({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{const r=n.tail();n.set(t,!0),r&&o.size()>e&&o.delete(r.key)}});return o};const{TreeCache:$o}=xo,qo={equality:"reference",eviction:"keep-all",maxSize:1/0};var Wo=function({equality:e=qo.equality,eviction:t=qo.eviction,maxSize:n=qo.maxSize}=qo){return function(e,t,n){switch(e){case"keep-all":return new $o({mapNodeValue:n});case"lru":return Po(i(t),n);case"most-recent":return Po(1,n)}throw new Error(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>Vo(e)}throw new Error(`Unrecognized equality policy ${e}`)}(e))};var Go={startPerfBlock:function(e){return()=>null}};const{CANCELED:jo,Canceled:Ho,loadableWithError:Ko,loadableWithPromise:Zo,loadableWithValue:Jo}=p,{getNodeLoadable:Qo,peekNodeLoadable:Xo,setNodeValue:Yo}=oe,{saveDependencyMapToStore:er}=Ie,{DEFAULT_VALUE:tr,RecoilValueNotReady:nr,getConfigDeletionHandler:or,registerNode:rr}=W,{isRecoilValue:ar}=D,{AbstractRecoilValue:ir}=D,{setRecoilValueLoadable:sr}=Re,{retainedByOptionWithDefault:ur}=ct,{cloneSnapshot:cr}=xt,{startPerfBlock:lr}=Go,dr=[],fr=new Map,hr=(()=>{let e=0;return()=>e++})();var pr=function(e){const{key:t,get:n,cachePolicy_UNSTABLE:o}=e,r=null!=e.set?e.set:void 0,s=Wo(null!==o&&void 0!==o?o:{equality:"reference",eviction:"keep-all"}),u=ur(e.retainedBy_UNSTABLE),c=new Map;let l=0;function d(){return!S("recoil_memory_managament_2020")||l>0}function f(e){return c.has(e)||c.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null}),i(c.get(e))}function h(e){return l++,e.getState().knownSelectors.add(t),()=>{l--,e.getState().knownSelectors.delete(t),c.delete(e)}}function p(){return void 0!==or(t)&&!d()}function v(e,t,n){if("loading"===t.state){let t=fr.get(n);null==t&&fr.set(n,t=new Set),t.add(e)}}function y(e,t,n){const o=e.getState().knownSelectors.has(n);if(o&&t.atomValues.has(n))return i(t.atomValues.get(n));const r=Qo(e,t,n);return"loading"!==r.state&&o&&t.atomValues.set(n,r),r}function _(e,n,o,r,a){return n.then((n=>{if(!d())return L(e,a),jo;if(n instanceof Ho)return w("Selector was released while it had dependencies"),jo;const{__key:r,__value:i}=null!==n&&void 0!==n?n:{};let s=!0;null!=r&&(o.atomValues.set(r,Jo(i)),s=!1);const u=T(e,o);if(u&&"hasValue"===u.state)return k(u,e),{__value:u.contents,__key:t};if(!M(e,a)){var c;const e=E(o);if("loading"===(null===e||void 0===e||null===(c=e.latestLoadable)||void 0===c?void 0:c.state))return e.latestLoadable.contents}const[l,f]=b(e,o,a,s);if(M(e,a)&&V(f,e,a),C(l),"loading"!==l.state&&(U(o,R(f),l),g(e,o,new Set(f.keys()),a),m(e,l,a)),"hasError"===l.state)throw l.contents;return"hasValue"===l.state?{__value:l.contents,__key:t}:l.contents})).catch((t=>{if(!d())return L(e,a),jo;const n=Ko(t);throw B(t),U(o,R(r),Ko(t)),g(e,o,new Set(r.keys()),a),m(e,n,a),t}))}function m(e,n,o){M(e,o)&&(k(n,e),function(e,n){const o=fr.get(n);if(void 0!==o){for(const n of o)sr(n,new ir(t),e);fr.delete(n)}}(n,o))}function g(e,n,o,r){var a,i,s,u,c,l,d;(M(e,r)||n.version===(null===(a=e.getState())||void 0===a||null===(i=a.currentTree)||void 0===i?void 0:i.version)||n.version===(null===(s=e.getState())||void 0===s||null===(u=s.nextTree)||void 0===u?void 0:u.version))&&er(new Map([[t,o]]),e,null!==(c=null===(l=e.getState())||void 0===l||null===(d=l.nextTree)||void 0===d?void 0:d.version)&&void 0!==c?c:e.getState().currentTree.version)}function b(e,o,r,i=!1){const s=lr(t);let u,c,l=!1;const f=new Map,h=new Set;function p(t){const{key:n}=t;!function(e,t,n,o,r){n.add(o),g(e,t,n,r)}(e,o,h,n,r);const a=i?Qo(e,o,n):y(e,o,n);if(C(a),f.set(n,a),"hasValue"===a.state)return a.contents;throw a.contents}g(e,o,h,r);let v=!1;const S=t=>(...n)=>{if(!v)throw new Error("getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can obtain the current Recoil state without a subscription.");const o=cr(e),r=t({snapshot:o});if("function"!==typeof r)throw new Error("getCallback() expects a function that returns a function.");return r(...n)};try{u=n({get:p,getCallback:S}),u=ar(u)?p(u):u,v=!0,a(u)?u=function(e,n,o,r,i){return n.then((n=>{if(!d())return L(e,i),jo;const a=Jo(n);return B(n),U(o,R(r),a),g(e,o,new Set(r.keys()),i),m(e,a,i),{__value:n,__key:t}})).catch((t=>{if(!d())return L(e,i),jo;if(M(e,i)&&V(r,e,i),a(t))return _(e,t,o,r,i);const n=Ko(t);throw B(t),U(o,R(r),n),g(e,o,new Set(r.keys()),i),m(e,n,i),t}))}(e,u,o,f,r).finally(s):s()}catch(w){u=w,a(u)?u=_(e,u,o,f,r).finally(s):(l=!0,s())}return c=l?Ko(u):a(u)?Zo(u):Jo(u),C(c),[c,f]}function T(e,n){const o=new Set,r=f(e),a=s.get((t=>{"string"!==typeof t&&Nn(!1);return y(e,n,t).contents}),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==t&&"string"===typeof e.nodeKey&&o.add(e.nodeKey)}});return a&&g(e,n,o,r.latestExecutionId),a}function R(e){return Array.from(e.entries()).map((([e,t])=>[e,t.contents]))}function A(e,t){const n=hr(),[o,r]=b(e,t,n);return k(o,e,r,n,t),function(e,t,n){"loading"!==n.state&&U(e,t,n)}(t,R(r),o),v(e,o,n),o}function E(e){var t;const[,n]=null!==(t=Array.from(c.entries()).find((([t,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,o;const r=f(e),a=null!==(n=r.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,i=Array((null!==(o=N.get(t.version))&&void 0!==o?o:new Map).entries()),s=N.has(t.version)&&i.length===a.size&&i.every((([e,t])=>a.get(e)===t));if(null==a||t.version===r.stateVersion||s)return!1;return N.set(t.version,new Map(a)),Array.from(a).some((([n,o])=>y(e,t,n).contents!==o.contents))}(t,e))))&&void 0!==t?t:[];return n}const N=new Map;function k(e,t,n,o,r){const a=f(t);"loading"===e.state?(a.depValuesDiscoveredSoFarDuringAsyncWork=n,a.latestExecutionId=o,a.latestLoadable=e,a.stateVersion=null===r||void 0===r?void 0:r.version):(a.depValuesDiscoveredSoFarDuringAsyncWork=null,a.latestExecutionId=null,a.latestLoadable=null,a.stateVersion=null)}function V(e,t,n){const o=f(t);M(t,n)&&(o.depValuesDiscoveredSoFarDuringAsyncWork=e)}function L(e,t){M(e,t)&&c.delete(e)}function M(e,t){return t===f(e).latestExecutionId}function C(e){"loading"!==e.state&&B(e.contents)}function B(e){0}function U(e,n,o){e.atomValues.set(t,o),s.set(n,o)}function D(e,t){return s.get((n=>{"string"!==typeof n&&Nn(!1);const o=Xo(e,t,n);return null===o||void 0===o?void 0:o.contents}))}function x(e,n){return function(e){if(dr.includes(t)){const e=`Recoil selector has circular dependencies: ${dr.slice(dr.indexOf(t)).join(" \u2192 ")}`;return Ko(new Error(e))}dr.push(t);try{return e()}finally{dr.pop()}}((()=>function(e,t){const n=T(e,t);if(null!=n)return k(n,e),n;const o=E(t);if(o){const t=o;return v(e,i(t.latestLoadable),i(t.latestExecutionId)),i(t.latestLoadable)}return A(e,t)}(e,n)))}function I(e){e.atomValues.delete(t)}if(null!=r){return rr({key:t,nodeType:"selector",peek:D,get:x,set:(e,t,n)=>{let o=!1;const i=new Map;function s({key:n}){if(o)throw new Error("Recoil: Async selector sets are not currently supported.");const r=y(e,t,n);if(C(r),"hasValue"===r.state)return r.contents;throw"loading"===r.state?new nr(n):r.contents}function u(n,r){if(o)throw new Error("Recoil: Async selector sets are not currently supported.");const a="function"===typeof r?r(s(n)):r;Yo(e,t,n.key,a).forEach(((e,t)=>i.set(t,e)))}const c=r({set:u,get:s,reset:function(e){u(e,tr)}},n);if(void 0!==c)throw a(c)?new Error("Recoil: Async selector sets are not currently supported."):new Error("Recoil: selector set should be a void function.");return o=!0,i},init:h,invalidate:I,shouldDeleteConfigOnRelease:p,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}return rr({key:t,nodeType:"selector",peek:D,get:x,init:h,invalidate:I,shouldDeleteConfigOnRelease:p,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})};const{loadableWithError:vr,loadableWithPromise:yr,loadableWithValue:_r}=p,{DEFAULT_VALUE:mr,DefaultValue:gr,getConfigDeletionHandler:Sr,registerNode:wr,setConfigDeletionHandler:br}=W,{isRecoilValue:Tr}=D,{markRecoilValueModified:Rr,setRecoilValue:Ar,setRecoilValueLoadable:Er}=Re,{retainedByOptionWithDefault:Nr}=ct;function kr(e){const{key:t,persistence_UNSTABLE:n}=e,o=Nr(e.retainedBy_UNSTABLE);let r,s=0,u=a(e.default)?yr(e.default.then((e=>{u=_r(e);return{__key:t,__value:e}})).catch((e=>{throw u=vr(e),e}))):_r(e.default);const c=new Map;const l=wr({key:t,nodeType:"atom",peek:function(e,n){var o,a,i;return null!==(o=null!==(a=n.atomValues.get(t))&&void 0!==a?a:null===(i=r)||void 0===i?void 0:i[1])&&void 0!==o?o:u},get:function(e,o){if(o.atomValues.has(t))return i(o.atomValues.get(t));if(o.nonvalidatedAtoms.has(t)){if(null!=r)return r;if(null==n)return A(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),u;const e=o.nonvalidatedAtoms.get(t),a=n.validator(e,mr),i=a instanceof gr?u:_r(a);return r=i,r}return u},set:function(e,n,o){if(n.atomValues.has(t)){const e=i(n.atomValues.get(t));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!n.nonvalidatedAtoms.has(t)&&o instanceof gr)return new Map;return r=void 0,(new Map).set(t,_r(o))},init:function(n,o,r){s++;const i=n.getState().knownAtoms.has(t);if(n.getState().knownAtoms.add(t),"loading"===u.state){const e=()=>{var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||Rr(n,l)};u.contents.then(e).catch(e)}let d=mr,f=null;if(null!=e.effects_UNSTABLE&&!i){let o=!0;const i=e=>t=>{if(o){const n=d instanceof gr||a(d)?"hasValue"===u.state?u.contents:mr:d;d="function"===typeof t?t(n):t,a(d)&&(d=d.then((t=>(f={effect:e,value:t},t))))}else{if(a(t))throw new Error("Setting atoms to async values is not implemented.");"function"!==typeof t&&(f={effect:e,value:t}),Ar(n,l,"function"===typeof t?n=>{const o=t(n);return f={effect:e,value:o},o}:t)}},s=e=>()=>i(e)(mr),v=e=>o=>{n.subscribeToTransactions((n=>{var r;let{currentTree:a,previousTree:i}=n.getState();i||(w("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),i=a);const s=null!==(r=a.atomValues.get(t))&&void 0!==r?r:u;if("hasValue"===s.state){var c,l,d,h;const n=s.contents,r=null!==(c=i.atomValues.get(t))&&void 0!==c?c:u,a="hasValue"===r.state?r.contents:mr;(null===(l=f)||void 0===l?void 0:l.effect)!==e||(null===(d=f)||void 0===d?void 0:d.value)!==n?o(n,a):(null===(h=f)||void 0===h?void 0:h.effect)===e&&(f=null)}}),t)};for(const t of null!==(h=e.effects_UNSTABLE)&&void 0!==h?h:[]){var h;const e=t({node:l,trigger:r,setSelf:i(t),resetSelf:s(t),onSet:v(t)});var p;if(null!=e)c.set(n,[...null!==(p=c.get(n))&&void 0!==p?p:[],e])}o=!1}if(!(d instanceof gr)){var v;const e=a(d)?yr(function(e,n){const o=n.then((n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&Ar(e,l,n),{__key:t,__value:n}})).catch((n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&Er(e,l,vr(n)),n}));return o}(n,d)):_r(d);o.atomValues.set(t,e),null===(v=n.getState().nextTree)||void 0===v||v.atomValues.set(t,e)}return()=>{var e;s--,null===(e=c.get(n))||void 0===e||e.forEach((e=>e())),c.delete(n),n.getState().knownAtoms.delete(t)}},invalidate:function(){r=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==Sr(t)&&s<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return l}function Vr(e){const{default:t,...n}=e;return Tr(t)?function(e){const t=Vr({...e,default:mr,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof gr?t:i(e.persistence_UNSTABLE).validator(t,mr)},effects_UNSTABLE:e.effects_UNSTABLE}),n=pr({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof gr?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return br(n.key,Sr(e.key)),n}({...n,default:t}):kr({...n,default:t})}var Lr=Vr;var Mr=class{constructor(e){var t;E(this,"_map",void 0),E(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null===e||void 0===e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}},Cr=Object.freeze({__proto__:null,MapCache:Mr});const{LRUCache:Br}=zo,{MapCache:Ur}=Cr,Dr={equality:"reference",eviction:"none",maxSize:1/0};var xr=function({equality:e=Dr.equality,eviction:t=Dr.eviction,maxSize:n=Dr.maxSize}=Dr){return function(e,t,n){switch(e){case"keep-all":return new Ur({mapKey:n});case"lru":return new Br({mapKey:n,maxSize:i(t)});case"most-recent":return new Br({mapKey:n,maxSize:1})}throw new Error(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>Vo(e)}throw new Error(`Unrecognized equality policy ${e}`)}(e))};const{setConfigDeletionHandler:Ir}=W;var zr=function(e){var t,n;const o=xr({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;const r=o.get(t);if(null!=r)return r;const{cachePolicyForParams_UNSTABLE:a,...i}=e,s=Lr({...i,key:`${e.key}__${null!==(n=Vo(t))&&void 0!==n?n:"void"}`,default:"function"===typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects_UNSTABLE:"function"===typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):e.effects_UNSTABLE});return o.set(t,s),Ir(s.key,(()=>{o.delete(t)})),s}};const{setConfigDeletionHandler:Fr}=W;let Or=0;var Pr=function(e){var t,n;const o=xr({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;const r=o.get(t);if(null!=r)return r;const a=`${e.key}__selectorFamily/${null!==(n=Vo(t,{allowFunctions:!0}))&&void 0!==n?n:"void"}/${Or++}`,i=n=>e.get(t)(n),s=e.cachePolicy_UNSTABLE,u="function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;let c;if(null!=e.set){const n=e.set;c=pr({key:a,get:i,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:s,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u})}else c=pr({key:a,get:i,cachePolicy_UNSTABLE:s,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u});return o.set(t,c),Fr(c.key,(()=>{o.delete(t)})),c}};const $r=Pr({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var qr=function(e){return $r(e)};const Wr=Pr({key:"__error",get:e=>()=>{throw new Error(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Gr=function(e){return Wr(e)};var jr=function(e){return e};const{loadableWithError:Hr,loadableWithPromise:Kr,loadableWithValue:Zr}=p;function Jr(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[a,i]of t.entries())try{n[a]=e(i)}catch(r){o[a]=r}return[n,o]}function Qr(e){return null!=e&&!a(e)}function Xr(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))}function Yr(e){return null!=e&&"object"===typeof e&&e.hasOwnProperty("__value")?e.__value:e}function ea(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})}function ta(e,t,n){return ea(e,n.map(((e,n)=>null==e?Zr(t[n]):a(e)?Kr(e):Hr(e))))}var na={waitForNone:Pr({key:"__waitForNone",get:e=>({get:t})=>{const n=Xr(e),[o,r]=Jr(t,n);return ta(e,o,r)},dangerouslyAllowMutability:!0}),waitForAny:Pr({key:"__waitForAny",get:e=>({get:t})=>{const n=Xr(e),[o,r]=Jr(t,n);return r.some((e=>!a(e)))?ta(e,o,r):new Promise((t=>{for(const[n,i]of r.entries())a(i)&&i.then((a=>{o[n]=Yr(a),r[n]=void 0,t(ta(e,o,r))})).catch((a=>{r[n]=a,t(ta(e,o,r))}))}))},dangerouslyAllowMutability:!0}),waitForAll:Pr({key:"__waitForAll",get:e=>({get:t})=>{const n=Xr(e),[o,r]=Jr(t,n);if(r.every((e=>null==e)))return ea(e,o);const a=r.find(Qr);if(null!=a)throw a;return Promise.all(r).then((t=>{return ea(e,(n=o,r=t,r.map(((e,t)=>void 0===e?n[t]:e))).map(Yr));var n,r}))},dangerouslyAllowMutability:!0}),waitForAllSettled:Pr({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Xr(e),[o,r]=Jr(t,n);return r.every((e=>!a(e)))?ta(e,o,r):Promise.all(r.map(((e,t)=>a(e)?e.then((e=>{o[t]=Yr(e),r[t]=void 0})).catch((e=>{o[t]=void 0,r[t]=e})):null))).then((()=>ta(e,o,r)))},dangerouslyAllowMutability:!0}),noWait:Pr({key:"__noWait",get:e=>({get:t})=>{try{return Zr(t(e))}catch(n){return a(n)?Kr(n):Hr(n)}},dangerouslyAllowMutability:!0})};const{batchUpdates:oa,setBatcher:ra}=Ce,{DefaultValue:aa}=W,{RecoilRoot:ia}=hn,{isRecoilValue:sa}=D,{retentionZone:ua}=j,{freshSnapshot:ca}=xt,{useGotoRecoilSnapshot:la,useRecoilCallback:da,useRecoilSnapshot:fa,useRecoilState:ha,useRecoilStateLoadable:pa,useRecoilTransaction:va,useRecoilTransactionObserver:ya,useRecoilValue:_a,useRecoilValueLoadable:ma,useResetRecoilState:ga,useRetain:Sa,useSetRecoilState:wa,useSetUnvalidatedAtomValues:ba,useTransactionObservation_DEPRECATED:Ta}=mo,{noWait:Ra,waitForAll:Aa,waitForAllSettled:Ea,waitForAny:Na,waitForNone:ka}=na;var Va={DefaultValue:aa,RecoilRoot:ia,useRecoilBridgeAcrossReactRoots_UNSTABLE:Ao,atom:Lr,selector:pr,retentionZone:ua,atomFamily:zr,selectorFamily:Pr,constSelector:qr,errorSelector:Gr,readOnlySelector:jr,useRecoilValue:_a,useRecoilValueLoadable:ma,useRecoilState:ha,useRecoilStateLoadable:pa,useSetRecoilState:wa,useResetRecoilState:ga,useGetRecoilValueInfo_UNSTABLE:wo,useRetain:Sa,useRecoilCallback:da,useRecoilTransaction_UNSTABLE:va,useGotoRecoilSnapshot:la,useRecoilSnapshot:fa,useRecoilTransactionObserver_UNSTABLE:ya,useTransactionObservation_UNSTABLE:Ta,useSetUnvalidatedAtomValues_UNSTABLE:ba,noWait:Ra,waitForNone:ka,waitForAny:Na,waitForAll:Aa,waitForAllSettled:Ea,isRecoilValue:sa,batchUpdates:oa,setBatcher:ra,snapshot_UNSTABLE:ca},La=Va.RecoilRoot,Ma=Va.atomFamily,Ca=Va.useRecoilState,Ba=Va.useSetRecoilState}}]);